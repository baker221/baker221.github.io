<!DOCTYPE html>
<html lang="zh-CN">
    <head>
    <meta charset="utf-8">

    

    <!-- 渲染优化 -->
    <meta name="renderer" content="webkit">
    <meta name="force-rendering" content="webkit">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="HandheldFriendly" content="True" >
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <!--icon-->

    <link rel="shortcut icon" type='image/x-icon' href="/favicon.ico">


    <!-- meta -->


<title>程设期中复习 | Baker&#39;s blog</title>


    <meta name="keywords" content="哈哈哈">




    <!-- OpenGraph -->
 
    <meta name="description" content="程设期中复习PPT1命令行参数    int argc, char * argv[] argc命令行参数的个数 至少是1（可执行程序的文件名也算一个命令行参数）   argv 存储char *类型指针的数组   （即：char **类型）  scanf和printf printf返回值 成功打印字符数 &lt;0 输出出错   %p 输出地址 scanf函数格式中,如有非控制符也非空格字符,且输入">
<meta property="og:type" content="article">
<meta property="og:title" content="程设期中复习">
<meta property="og:url" content="https://blog.baker221.codes/2019/08/15/%E7%A8%8B%E8%AE%BE%E6%9C%9F%E4%B8%AD%E5%A4%8D%E4%B9%A0/index.html">
<meta property="og:site_name" content="Baker&#39;s blog">
<meta property="og:description" content="程设期中复习PPT1命令行参数    int argc, char * argv[] argc命令行参数的个数 至少是1（可执行程序的文件名也算一个命令行参数）   argv 存储char *类型指针的数组   （即：char **类型）  scanf和printf printf返回值 成功打印字符数 &lt;0 输出出错   %p 输出地址 scanf函数格式中,如有非控制符也非空格字符,且输入">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://ws4.sinaimg.cn/large/aacdf46cly1g2wj6qhdauj20or0aswjh.jpg">
<meta property="article:published_time" content="2019-08-14T16:33:44.000Z">
<meta property="article:modified_time" content="2019-11-18T03:08:22.000Z">
<meta property="article:author" content="baker221">
<meta property="article:tag" content="哈哈哈">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://ws4.sinaimg.cn/large/aacdf46cly1g2wj6qhdauj20or0aswjh.jpg">


    
<link rel="stylesheet" href="/css/style/main.css">
 



    
    
        <link rel="stylesheet" id="hl-default-theme" href="/css/highlight/default.css" media="none" onload="if(getComputedStyle(document.documentElement).getPropertyValue('--color-mode').indexOf('dark')===-1)this.media='all'">
        
    

    
    

     

    <!-- custom head -->

<meta name="generator" content="Hexo 5.2.0"></head>

    <body>
        <div id="app">
            <header class="header">
    <div class="header__left">
        <a href="/" class="button">
            <span class="logo__text">
                Baker&#39;s blog
            </span>
        </a>
    </div>
    <div class="header__right">
        
            <div class="navbar__menus">
                
                    <a href="/" class="navbar-menu button">
                        Home
                    </a>
                
                    <a href="/tags/" class="navbar-menu button">
                        Tag
                    </a>
                
                    <a href="/archives/" class="navbar-menu button">
                        Archive
                    </a>
                
                    <a href="/friends/" class="navbar-menu button">
                        Friend
                    </a>
                
                    <a href="/page/" class="navbar-menu button">
                        Page
                    </a>
                
            </div>
        
        
        

        
        

        

        
            <a class="dropdown-icon button" id="btn-dropdown">
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" width='24' height='24' fill="none" stroke="currentColor" stroke-width="0.7" stroke-linecap="round" stroke-linejoin="round">
                    <path fill="currentColor" d="M3.314,4.8h13.372c0.41,0,0.743-0.333,0.743-0.743c0-0.41-0.333-0.743-0.743-0.743H3.314c-0.41,0-0.743,0.333-0.743,0.743C2.571,4.467,2.904,4.8,3.314,4.8z M16.686,15.2H3.314c-0.41,0-0.743,0.333-0.743,0.743s0.333,0.743,0.743,0.743h13.372c0.41,0,0.743-0.333,0.743-0.743S17.096,15.2,16.686,15.2z M16.686,9.257H3.314c-0.41,0-0.743,0.333-0.743,0.743s0.333,0.743,0.743,0.743h13.372c0.41,0,0.743-0.333,0.743-0.743S17.096,9.257,16.686,9.257z"></path>
                </svg>
            </a>
            <div class="dropdown-menus" id="dropdown-menus">
                
                    <a href="/" class="dropdown-menu button">
                        Home
                    </a>
                
                    <a href="/tags/" class="dropdown-menu button">
                        Tag
                    </a>
                
                    <a href="/archives/" class="dropdown-menu button">
                        Archive
                    </a>
                
                    <a href="/friends/" class="dropdown-menu button">
                        Friend
                    </a>
                
                    <a href="/page/" class="dropdown-menu button">
                        Page
                    </a>
                
            </div>
        
    </div>
</header>


            <main class="main">
    

<div class="post-title">
    <h1 class="post-title__text">
        程设期中复习
    </h1>
    <div class="post-title__meta">
        <a href="/archives/2019/08/" class="post-meta__date button">
    2019-08-15
</a>
        
    <span class="separate-dot"></span><a href="/categories/%E5%91%B5%E5%91%B5%E5%91%B5/" class="button">呵呵呵</a>

 
        
    
    


 

 
    </div>
</div>



<article class="post content-card">
    <div class="post__header"></div>
    <div class="post__content">
        <h1 id="程设期中复习"><a href="#程设期中复习" class="headerlink" title="程设期中复习"></a>程设期中复习</h1><h2 id="PPT1"><a href="#PPT1" class="headerlink" title="PPT1"></a>PPT1</h2><h3 id="命令行参数-int-argc-char-argv"><a href="#命令行参数-int-argc-char-argv" class="headerlink" title="命令行参数    int argc, char * argv[]"></a>命令行参数    int argc, char * argv[]</h3><ul>
<li>argc命令行参数的个数<ul>
<li>至少是1（可执行程序的文件名也算一个命令行参数）</li>
</ul>
</li>
<li>argv 存储char *类型指针的数组   （即：char **类型）</li>
</ul>
<h3 id="scanf和printf"><a href="#scanf和printf" class="headerlink" title="scanf和printf"></a>scanf和printf</h3><ul>
<li>printf返回值<ul>
<li>成功打印字符数</li>
<li>&lt;0 输出出错</li>
</ul>
</li>
<li>%p 输出地址</li>
<li>scanf函数格式中,如有非控制符也非空格字符,且输入数据中相应位置也出现该字符-&gt;该字符会被跳过</li>
</ul>
<h3 id="sscanf和sprintf：从buffer中读取和输出数据"><a href="#sscanf和sprintf：从buffer中读取和输出数据" class="headerlink" title="sscanf和sprintf：从buffer中读取和输出数据"></a>sscanf和sprintf：从buffer中读取和输出数据</h3><h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><ul>
<li>负整数的表示方式：取反加1</li>
</ul>
<p>按位异或</p>
<ul>
<li>特点：若 a^b=c，则有c^b=a以及c^a=b</li>
<li>某一位异或1就相当于取反</li>
</ul>
<p>左/右移</p>
<ul>
<li>大多数C/C++编译器规定<ul>
<li>若原符号位为1，则右移时高位补充1</li>
<li>若原符号为为0，则右移时高位补充0</li>
</ul>
</li>
<li>无符号数右移时高位<strong>总是补0</strong></li>
</ul>
<h3 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h3><ul>
<li>一般形式为：类型名(*指针变量名)(参数类型1， 参数类型2， ……)</li>
</ul>
<h3 id="动态内存分配"><a href="#动态内存分配" class="headerlink" title="动态内存分配"></a>动态内存分配</h3><p>new   delete</p>
<h3 id="C语言标准库函数"><a href="#C语言标准库函数" class="headerlink" title="C语言标准库函数"></a>C语言标准库函数</h3><ul>
<li>strchr     如果串s中包含字符c，则返回一个指向s第一次出现的该字符的指针，否则返回NULL</li>
<li>stricmp 比较两个字符串，忽略大小写。其他和strcmp同</li>
<li>atoi</li>
<li>atof</li>
<li>itoa   将整型值value以radix进制表示法写入string</li>
</ul>
<h2 id="PPT2-类和对象1"><a href="#PPT2-类和对象1" class="headerlink" title="PPT2 类和对象1"></a>PPT2 类和对象1</h2><ul>
<li>引用</li>
<li>常引用<ul>
<li>不能通过常引用修改其引用的内容</li>
<li>const T&amp; 和 T&amp;是不同的类型</li>
</ul>
</li>
<li>对象成员的访问权限<ul>
<li>在类成员函数的内部，能够访问<ul>
<li>当前对象的全部属性，函数</li>
<li><strong>同类其它对象</strong>的全部属性，函数</li>
</ul>
</li>
<li>在类的成员函数以外的地方，只能够访问该类对象的公有成员</li>
<li>设置私有成员的机制叫<strong>隐藏</strong></li>
</ul>
</li>
</ul>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><ul>
<li>private构造函数不能直接用来初始化对象</li>
</ul>
<h3 id="复制构造函数"><a href="#复制构造函数" class="headerlink" title="复制构造函数"></a>复制构造函数</h3><p>调用情况：</p>
<ol>
<li>用一个对象<strong>初始化</strong>同类的另一个对象</li>
<li>某函数有一个<strong>参数</strong>是类A的对象</li>
<li>函数<strong>返回值</strong>是类A的对象</li>
</ol>
<p>对象间用等号赋值<strong>不会</strong>导致复制构造函数被调用！！</p>
<h2 id="PPT-3"><a href="#PPT-3" class="headerlink" title="PPT 3"></a>PPT 3</h2><h3 id="类型转换构造函数"><a href="#类型转换构造函数" class="headerlink" title="类型转换构造函数"></a>类型转换构造函数</h3><ul>
<li>起到类型自动转换的作用<ul>
<li>需要时编译系统会自动调用转换构造函数，建立一个<strong>无名的临时对象</strong>（或临时变量）</li>
</ul>
</li>
</ul>
<h3 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h3><ul>
<li>inline关键字</li>
<li>将整个函数体写在<strong>类定义内部</strong>，函数也会成为内联成员函数</li>
</ul>
<h3 id="函数参数的默认值"><a href="#函数参数的默认值" class="headerlink" title="函数参数的默认值"></a>函数参数的默认值</h3><ul>
<li>省略的参数一定是<strong>最右边连续</strong>几个，即不能<code>f( , 8)</code></li>
<li>使用缺省参数时要避免有函数重载时的二义性</li>
</ul>
<h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><ul>
<li>一个类最多只有一个析构函数（实际上一定有一个，只是不写自己的构造函数的话缺省构造函数<strong>什么也不做</strong>）</li>
<li>构造函数调用<ul>
<li>对象数组生命期结束时，对象数组的每个元素的析构函数都会被调用</li>
<li>delete运算导致析构函数调用<ul>
<li><strong>注意</strong>：new出来的对象如果不delete就不会消亡！</li>
</ul>
</li>
<li>构造函数在对象作为函数返回值返回后被调用</li>
<li>临时对象消亡时调用</li>
</ul>
</li>
</ul>
<h3 id="静态成员变量和静态成员函数"><a href="#静态成员变量和静态成员函数" class="headerlink" title="静态成员变量和静态成员函数"></a>静态成员变量和静态成员函数</h3><ul>
<li>静态成员<ul>
<li>说明前加static</li>
<li>被<strong>所有对象</strong>共享</li>
<li>若为public，在<strong>没有对象生成</strong>的时候也能直接访问</li>
</ul>
</li>
<li>访问静态成员的方式<ul>
<li>类名::成员名</li>
<li>和普通成员变量一样的形式</li>
</ul>
</li>
<li>静态成员变量不会属于某个特定对象，静态成员函数不会作用于某个特定对象</li>
<li>sizeof运算符不会计算静态成员变量</li>
<li>静态成员变量本质上是全局变量，静态成员函数本质上是全局函数</li>
<li>使用时<strong>必须</strong>在类定义的外面专门对静态成员变量进行声明，同行可以初始化；否则编译能通过，链接不能通过</li>
<li>静态成员函数中<ul>
<li>不能访问非静态成员变量</li>
<li>不能调用非静态成员函数</li>
</ul>
</li>
</ul>
<h3 id="const的用法"><a href="#const的用法" class="headerlink" title="const的用法"></a>const的用法</h3><ul>
<li>定义常量</li>
<li>对指针定义，则不可通过该指针指向其指向地方的内容<ul>
<li>不能把常量指针赋值给非常量指针，<strong>反过来可以</strong></li>
</ul>
</li>
</ul>
<h4 id="常量对象和常量方法"><a href="#常量对象和常量方法" class="headerlink" title="常量对象和常量方法"></a>常量对象和常量方法</h4><ul>
<li>若不希望某个对象值被改变-&gt;定义该对象时可以再前面加const关键字</li>
<li>常量对象只能使用：构造函数，析构函数和有const说明的函数（常量方法）</li>
<li>类的成员函数说明<strong>后面</strong>加const关键字，则该成员函数称为常量成员函数</li>
<li>常量成员函数内部不能改<strong>非静态属性的值</strong>，也不能调用同类的非常量成员函数（<strong>静态成员函数除外</strong>）</li>
<li>在<strong>定义</strong>和<strong>声明</strong>常量成员函数时都应该使用const关键字</li>
</ul>
<p>两个函数，名字和参数表一样，但是一个是const，一个不是，算<strong>重载</strong></p>
<h3 id="成员对象和封闭类"><a href="#成员对象和封闭类" class="headerlink" title="成员对象和封闭类"></a>成员对象和封闭类</h3><ul>
<li>成员对象：一个类的成员变量另一个类的对象</li>
<li>有成员对象的类叫封闭类</li>
<li>任何生成封闭类对象的语句，都要让编译器明白对象中的成员对象是如何初始化的</li>
<li>次序<ul>
<li>封闭类对象生成时对象成员构造函数调用次序和对象成员在类中说明次序一致，而与在初始化列表中出现的次序<strong>无关</strong></li>
<li>消亡调用析构函数的顺序和构造时相反</li>
</ul>
</li>
<li>初始化const成员和引用成员时，<strong>必须</strong>在成员初始化列表中进行</li>
</ul>
<h3 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h3><ul>
<li>友元函数<ul>
<li>可以将一个类的成员函数（<strong>包括构造、析构函数</strong>说明为另一个类的友元）</li>
</ul>
</li>
<li>友元类</li>
</ul>
<h3 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h3><ul>
<li><strong>非静态成员函数</strong>中可以直接使用this来代表指向该函数作用的对象的指针</li>
</ul>
<h2 id="PPT-4-运算符重载"><a href="#PPT-4-运算符重载" class="headerlink" title="PPT 4 运算符重载"></a>PPT 4 运算符重载</h2><p>运算符重载的实质是函数重载</p>
<ul>
<li>重载为成员函数时，参数个数为运算符目数<strong>减1</strong></li>
<li>重载为普通函数时，参数个数为运算符目数</li>
<li>重载赋值运算符的意义——浅拷贝和深拷贝</li>
</ul>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>C++不允许定义<strong>新的</strong>运算符</li>
<li>以下运算符<strong>不能</strong>被重载：<code>&quot;.&quot;, &quot;::&quot;, &quot;?:&quot;, sizeof</code>//第三个是三元运算符如<code>a &gt; b ? a : b</code></li>
<li>运算符(), [], -&gt;, =重载必须声明为类的<strong>成员函数</strong></li>
</ul>
<h3 id="流运算符"><a href="#流运算符" class="headerlink" title="流运算符"></a>流运算符</h3><ul>
<li>iostream中将&lt;&lt;重载为<strong>成员函数</strong></li>
</ul>
<h3 id="自增自减运算符的重载"><a href="#自增自减运算符的重载" class="headerlink" title="自增自减运算符的重载"></a>自增自减运算符的重载</h3><ul>
<li>前置作为<strong>一元运算符重载</strong>，返回值为增加后的值，且为<strong>引用</strong>(允许++++s)</li>
<li>后置多写一个<strong>没用</strong>的参数，返回值为原值（不允许s++++）</li>
</ul>
<h3 id="重载类型转换运算符"><a href="#重载类型转换运算符" class="headerlink" title="重载类型转换运算符"></a>重载类型转换运算符</h3><p>e.g. <code>operator int() &#123;return n;&#125;</code></p>
<h2 id="PPT-5-继承"><a href="#PPT-5-继承" class="headerlink" title="PPT 5 继承"></a>PPT 5 继承</h2><ul>
<li>友元类之间的关系<strong>不能传递</strong>，不能<strong>继承</strong>        //自己想法：但是好像模板类可以？（类模板友元全是模板类的友元？）   似乎</li>
<li>派生类的各成员函数不能访问<strong>基类</strong>的<strong>private</strong>成员</li>
</ul>
<h3 id="继承中的覆盖"><a href="#继承中的覆盖" class="headerlink" title="继承中的覆盖"></a>继承中的覆盖</h3><ul>
<li>派生类中定义一个和基类成员<strong>同名</strong>的成员，叫覆盖</li>
<li>缺省情况是访问派生类中定义的成员</li>
<li>要在派生类中访问基类定义的同名成员时，使用作用域符号<code>::</code></li>
</ul>
<h3 id="protected权限"><a href="#protected权限" class="headerlink" title="protected权限"></a>protected权限</h3><p>派生类的成员函数可以访问<strong>当前对象</strong>的基类的保护成员</p>
<p>e.g.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> :</span> <span class="keyword">public</span> Father&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AccessFather</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    nPublic = <span class="number">1</span>; <span class="comment">// ok;</span></span><br><span class="line">    nPrivate = <span class="number">1</span>; <span class="comment">// wrong</span></span><br><span class="line">    nProtected = <span class="number">1</span>; <span class="comment">// OK, 访问从基类继承的protected成员</span></span><br><span class="line">    Father f;</span><br><span class="line">    f.nProtected = <span class="number">1</span>; <span class="comment">//wrong, f不是函数所作用的当前对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="public继承的赋值兼容规则"><a href="#public继承的赋值兼容规则" class="headerlink" title="public继承的赋值兼容规则"></a>public继承的赋值兼容规则</h3><ul>
<li>派生类的对象可以<strong>赋值给基类对象</strong>，该基类对象不包含派生类成员</li>
<li>派生类对象可以初始化基类引用</li>
<li>派生类对象的地址可以赋值给基类指针</li>
<li>若派生方式是private或protected，则上述三条<strong>不可行</strong></li>
</ul>
<h2 id="PPT-6-多态"><a href="#PPT-6-多态" class="headerlink" title="PPT 6 多态"></a>PPT 6 多态</h2><p><img src="https://ws4.sinaimg.cn/large/aacdf46cly1g2wj6qhdauj20or0aswjh.jpg" alt="image"></p>
<p>==？？？？==和模拟期中的矛盾了。。。</p>
<p>面向对象程序设计特点：<strong>封装、继承、多态</strong></p>
<ul>
<li>多态：根据指针/引用指向的对象<strong>类型</strong>来决定调用的函数</li>
<li>在多层继承的情况下，从<strong>定义virtual开始</strong>的派生类中同名函数<strong>均为虚函数</strong>，无论是否加virtual</li>
<li>多态运行时才确定调用哪个函数而非<strong>编译时</strong>（动态联编）</li>
</ul>
<h3 id="虚函数的访问权限"><a href="#虚函数的访问权限" class="headerlink" title="虚函数的访问权限"></a>虚函数的访问权限</h3><ul>
<li>基类将虚函数变成私有成员会出错，但若将继承类的虚函数变为私有则不会有问题，也能正确调用（<strong>访问权限检查</strong>是根据<strong>指针类型</strong>来的）</li>
</ul>
<h3 id="构造函数和析构函数中调用虚函数"><a href="#构造函数和析构函数中调用虚函数" class="headerlink" title="构造函数和析构函数中调用虚函数"></a>构造函数和析构函数中调用虚函数</h3><ul>
<li>调用的是<strong>自己的类或基类</strong>中定义的函数，不会等到运行时才决定调用的是自己的还是派生类的函数</li>
</ul>
<h3 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h3><ul>
<li><strong>注意</strong>：不允许以虚函数作为<strong>构造函数</strong></li>
</ul>
<h3 id="纯虚函数和抽象类"><a href="#纯虚函数和抽象类" class="headerlink" title="纯虚函数和抽象类"></a>纯虚函数和抽象类</h3><ul>
<li>纯虚函数：没有函数体的虚函数 (=0)</li>
<li>包含纯虚函数的类叫抽象类<ul>
<li>抽象类只能作为基类来派生新类使用，<strong>不能创建</strong>抽象类的对象</li>
<li>抽象类的指针和引用可以指向由抽象类派生出来的类的对象</li>
</ul>
</li>
<li>抽象类的成员函数可以调用纯虚函数</li>
<li>在构造函数或析构函数内部不能调用纯虚函数</li>
<li>若一个类从抽象类派生而来，当且仅当它实现了基类中<strong>所有纯虚函数</strong>，它才成为非抽象类</li>
</ul>
<h1 id="此处转至PPT2018"><a href="#此处转至PPT2018" class="headerlink" title="此处转至PPT2018"></a>此处转至PPT2018</h1><h2 id="PPT8-类模板和函数模板"><a href="#PPT8-类模板和函数模板" class="headerlink" title="PPT8 类模板和函数模板"></a>PPT8 类模板和函数模板</h2><h3 id="函数和模板的匹配顺序"><a href="#函数和模板的匹配顺序" class="headerlink" title="函数和模板的匹配顺序"></a>函数和模板的匹配顺序</h3><ul>
<li>先找参数完全匹配的<strong>函数</strong></li>
<li>再找参数完全匹配的<strong>模板</strong></li>
<li>在没有二义性前提下，再找一个<strong>参数经过自动转换</strong>后能够匹配的函数</li>
<li>都找不到，则报错</li>
</ul>
<h3 id="类模板-模板类"><a href="#类模板-模板类" class="headerlink" title="类模板 模板类"></a>类模板 模板类</h3><ul>
<li>模板类=实例化的类模板</li>
<li>同一个类模板的两个<strong>模板类</strong>是不兼容的</li>
</ul>
<h3 id="类模板与非类型参数"><a href="#类模板与非类型参数" class="headerlink" title="类模板与非类型参数"></a>类模板与<strong>非类型参数</strong></h3><ul>
<li>非类型参数：用来说明类模板中的属性</li>
<li>通常在类模板参数声明中的非类型参数可以提高程序的执行效率<ul>
<li>在编译或链接期间即可确定参数的值</li>
</ul>
</li>
</ul>
<h3 id="类模板与继承"><a href="#类模板与继承" class="headerlink" title="类模板与继承"></a>类模板与继承</h3><h3 id="类模板与友元"><a href="#类模板与友元" class="headerlink" title="类模板与友元"></a>类模板与友元</h3><ul>
<li>在继承处关于友元的推测应该是<strong>有道理</strong>的</li>
</ul>
<h3 id="类模板与static成员"><a href="#类模板与static成员" class="headerlink" title="类模板与static成员"></a>类模板与static成员</h3><ul>
<li>从该类模板实例化得到的<strong>模板类的所有对象</strong>，都包含同样的静态成员，但是<strong>不同模板类</strong>不能共享静态变量</li>
</ul>
<h3 id="string类"><a href="#string类" class="headerlink" title="string类"></a>string类</h3><ul>
<li>不提供以<strong>字符</strong>和<strong>整数</strong>为参数的构造函数</li>
<li>可以将字符<strong>赋值</strong>给string对象</li>
</ul>
<h4 id="string的赋值与连接"><a href="#string的赋值与连接" class="headerlink" title="string的赋值与连接"></a>string的赋值与连接</h4><ul>
<li>赋值<ul>
<li>=</li>
<li>assign成员函数</li>
<li>用assign成员函数部分复制<code>s3.assign(s1, 1, 3)</code>下标为1开始复制3个字符</li>
</ul>
</li>
<li>[]不做范围检查，而成员函数at会</li>
<li>连接<ul>
<li>+</li>
<li>成员函数append<ul>
<li>全部</li>
<li>部分</li>
</ul>
</li>
</ul>
</li>
<li>比较string<ul>
<li>关系运算符</li>
<li>成员函数compare</li>
</ul>
</li>
</ul>
<ul>
<li>字串substr</li>
<li>交换string   成员函数swap</li>
</ul>
<h4 id="string的特性"><a href="#string的特性" class="headerlink" title="string的特性"></a>string的特性</h4><ul>
<li>capacity   无需增加内存即可存放的字符数</li>
<li>maximum_size  返回string对象可存放的最大字符数</li>
<li>length    size</li>
<li>empty</li>
<li>resize</li>
</ul>
<h4 id="寻找"><a href="#寻找" class="headerlink" title="寻找"></a>寻找</h4><h4 id="替换string中的字符"><a href="#替换string中的字符" class="headerlink" title="替换string中的字符"></a>替换string中的字符</h4><ul>
<li>成员函数erase()  去掉下标n<strong>及之后</strong>的字符</li>
<li>成员函数<code>replace(2, 3, &quot;haha&quot;)</code>将从下标2开始的三个字符换成”haha”<ul>
<li><code>replace(2, 3, &quot;haha&quot;, 1, 2)</code></li>
</ul>
</li>
</ul>
<h4 id="string中插入字符"><a href="#string中插入字符" class="headerlink" title="string中插入字符"></a>string中插入字符</h4><h4 id="转成C语言式char-字符串-c-str"><a href="#转成C语言式char-字符串-c-str" class="headerlink" title="转成C语言式char*字符串 c_str()"></a>转成C语言式char*字符串 c_str()</h4><h4 id="字符串流处理"><a href="#字符串流处理" class="headerlink" title="字符串流处理"></a>字符串流处理</h4><ul>
<li>用<code>istringstream</code>和<code>ostringstream</code>进行字符串上的输入输出，也成为<strong>内存输入输出</strong></li>
</ul>
<h2 id="PPT-9-标准模板库1"><a href="#PPT-9-标准模板库1" class="headerlink" title="PPT 9 标准模板库1"></a>PPT 9 标准模板库1</h2><ul>
<li>函数模板的返回值可以是确定的类型，也可以是<strong>由类型参数表示</strong>的非确定类型</li>
</ul>
<h3 id="STL三个基本概念"><a href="#STL三个基本概念" class="headerlink" title="STL三个基本概念"></a>STL三个基本概念</h3><ul>
<li>容器：容纳各种数据类型的数据结构</li>
<li>迭代器：可依次<strong>存取</strong>容器中元素的工具<ul>
<li>普通的C++指针就是一种迭代器</li>
</ul>
</li>
<li>算法：用来<strong>操作</strong>容器中元素的函数模板</li>
</ul>
<h3 id="容器概述"><a href="#容器概述" class="headerlink" title="容器概述"></a>容器概述</h3><p>三大类：</p>
<ol>
<li>顺序容器/序列容器</li>
<li>关联容器/有序容器（1，2称为第一类容器）</li>
<li>容器适配器</li>
</ol>
<p>对象插入容器时插入的是<strong>复制品</strong></p>
<p>顺序容器：元素插入位置与元素的值<strong>无关</strong></p>
<p>关联容器：插入时按照相应的排序准则确定其位置</p>
<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>指向<strong>第一类容器</strong>中的元素，分为const和非const两种</p>
<p><code>容器类名::iterator 变量名</code>     <code>容器类名::const_iterator 变量名</code></p>
<p>访问迭代器指向元素：<code>*迭代器变量名</code></p>
<p><strong>迭代器可以执行++操作</strong></p>
<p>STL中迭代器功能由弱变强：输入、输出、正向、双向、随机访问。</p>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><ul>
<li>大/小/相等的概念<ul>
<li>缺省情况下，比较大小用&lt;进行，和&gt;<strong>无关</strong></li>
<li>STL中比较两个元素是否相等<ul>
<li>未排序的区间：用==</li>
<li>排好序的区间进行查找、合并等：<code>x &lt; y 和 y &lt; x</code>同时为<strong>假</strong>，和==无关</li>
</ul>
</li>
</ul>
</li>
</ul>

    </div>
     
    <div class="post-footer__meta">
    <p>
        更新于 2019-11-18
    </p>
</div> 
    <div class="post-meta__cats">
    
        <a href="/categories/%E5%91%B5%E5%91%B5%E5%91%B5/" class="post-cats__link button">呵呵呵</a>
    
    
        <a href="/tags/%E5%93%88%E5%93%88%E5%93%88/" class="post-tags__link button"># 哈哈哈</a>
    
</div> 
</article>


    <div class="nav">
        <div class="nav__prev">
            
                <a href="/2019/11/18/hello/" class="nav__link">
                    <div>
                        <svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" width="24" height="24"><path d="M589.088 790.624L310.464 512l278.624-278.624 45.248 45.248L400.96 512l233.376 233.376z" fill="#808080"></path></svg>
                    </div>
                    <div>
                        <div class="nav__label">
                            Previous Post
                        </div>
                        <div class="nav__title">
                            数理逻辑笔记
                        </div>
                    </div>
                </a>
            
        </div>
        <div class="nav__next">
            
        </div>
    </div>





</main>

            <footer class="footer">
    


    
     
 

 
    
        
        <p class="footer-copyright">
            Copyright © 2020 <a href="/">Baker&#39;s blog</a>
        </p>
    
    
    <p>Powered by <a href="https://hexo.io" target="_blank">Hexo</a> | Theme - <a href="https://github.com/ChrAlpha/hexo-theme-cards" target="_blank">Cards</a></p>
</footer>

        </div>
         

 

 

 

  



 


    
 

 


    <script>
        if (typeof MathJax === 'undefined') {
            window.MathJax = {
                loader: {
                    source: {
                        '[tex]/amsCd': '[tex]/amscd',
                        '[tex]/AMScd': '[tex]/amscd'
                    }
                },
                tex: {
                    inlineMath: {'[+]': [['$', '$']]},
                    tags: 'ams'
                },
                options: {
                    renderActions: {
                        findScript: [10, doc => {
                            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                                const display = !!node.type.match(/; *mode=display/);
                                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                                const text = document.createTextNode('');
                                node.parentNode.replaceChild(text, node);
                                math.start = {node: text, delim: '', n: 0};
                                math.end = {node: text, delim: '', n: 0};
                                doc.math.push(math);
                            });
                        }, '', false],
                        insertedScript: [200, () => {
                            document.querySelectorAll('mjx-container').forEach(node => {
                                let target = node.parentNode;
                                if (target.nodeName.toLowerCase() === 'li') {
                                    target.parentNode.classList.add('has-jax');
                                }
                            });
                        }, '', false]
                    }
                }
            };
            (function () {
                var script = document.createElement('script');
                script.src = "https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js";
                script.defer = true;
                document.head.appendChild(script);
            })();
        } else {
            MathJax.startup.document.state(0);
            MathJax.texReset();
            MathJax.typeset();
        }
    </script>
 

 




    </body>
</html>
